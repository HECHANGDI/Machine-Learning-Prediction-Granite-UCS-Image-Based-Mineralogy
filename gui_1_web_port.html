<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Digital Image(s) Processing Tool – Web</title>
  <style>
    :root{
      --bg:#0b0c10; --panel:#14161b; --text:#e6e8ed; --muted:#a7afc0; --accent:#7aa2f7; --danger:#f7768e;
      --radius:14px; --shadow:0 12px 32px rgba(0,0,0,.25);
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f7f8fb; --panel:#ffffff; --text:#1c1f26; --muted:#5b6475; --accent:#365efb; --danger:#d7224a; }
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    header{max-width:1200px;margin:24px auto 8px;padding:0 16px;display:flex;justify-content:space-between;align-items:end}
    h1{font-size:20px;margin:0}
    .muted{color:var(--muted)}
    .app{max-width:1200px;margin:0 auto 36px;padding:16px;display:grid;gap:12px}
    .row{display:grid;gap:12px}
    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px}
    .cols{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
    .controls label{display:block;margin:6px 0 4px}
    input[type="text"], input[type="number"], select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.16);background:transparent;color:var(--text)}
    input[type="file"]{width:100%}
    button{padding:10px 12px;border-radius:10px;border:1px solid transparent;background:var(--accent);color:#fff;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;color:var(--text);border-color:rgba(255,255,255,.16)}
    button.danger{background:var(--danger)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    canvas{width:100%;height:auto;background:#0002;border-radius:10px;border:1px solid rgba(255,255,255,.12)}
    .checkboxes{display:grid;grid-template-columns:repeat(4, minmax(0,1fr));gap:6px;max-height:180px;overflow:auto;padding:6px;background:#0001;border:1px solid rgba(255,255,255,.12);border-radius:10px}
    .inline{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .small{font-size:12px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Digital Image(s) Processing Tool – Web</h1>
      <div class="muted small">Browser port of your Tkinter app: 2D/3D images, grayscale, equalization, thresholding, histogram, proportions, pixel-data export, and script generation.</div>
    </div>
  </header>

  <main class="app">
    <section class="panel controls">
      <div class="inline">
        <label class="inline">Mode:
          <select id="mode">
            <option value="2D">2D</option>
            <option value="3D">3D (multi-image stack)</option>
          </select>
        </label>
        <label class="inline">Load Image(s):
          <input id="fileInput" type="file" accept="image/*" />
        </label>
        <button id="btnLoad">Load</button>
      </div>
      <div class="cols">
        <div>
          <h3 class="small muted">Image Processing</h3>
          <div class="inline">
            <label>Resize W <input id="resizeW" type="number" step="1" min="1" placeholder="width" /></label>
            <label>H <input id="resizeH" type="number" step="1" min="1" placeholder="height" /></label>
            <button class="ghost" id="btnResize" disabled>Resize</button>
          </div>
          <div class="inline" style="margin-top:6px">
            <button id="btnGray" disabled>Grayscale</button>
            <button id="btnEq" class="ghost" disabled>Equalization</button>
          </div>
          <div style="margin-top:6px">
            <label>Thresholds (comma separated):
              <input id="thresholds" type="text" placeholder="e.g. 64,128,192" />
            </label>
            <button id="btnThresh" class="ghost" disabled>Apply Thresholding</button>
          </div>
          <div class="inline" style="margin-top:6px">
            <button id="btnSaveImg" class="ghost" disabled>Download Current Image</button>
          </div>
        </div>
        <div>
          <h3 class="small muted">Pixel Information Extraction</h3>
          <label>Sample Width (m)
            <input id="sampleWidth" type="number" step="any" placeholder="e.g. 0.75" />
          </label>
          <label>Sample Height (m) [3D]
            <input id="sampleHeight" type="number" step="any" placeholder="e.g. 0.30" disabled />
          </label>
          <label>Scaling Factor
            <input id="scalingFactor" type="number" step="any" value="1.0" />
          </label>
          <label>Origin Position
            <select id="origin">
              <option>center</option>
              <option>top-left</option>
              <option>top-right</option>
              <option>bottom-left</option>
              <option>bottom-right</option>
            </select>
          </label>
          <div id="pixelCheckboxes" class="checkboxes" title="Selected grayscale values for extraction will be used here."></div>
          <button id="btnExtract" disabled>Extract Pixel Data (.txt)</button>
        </div>
        <div>
          <h3 class="small muted">Python/Fish Script Generation</h3>
          <label>Code Type
            <select id="codeType">
              <option>Ball</option>
              <option>rblock</option>
            </select>
          </label>
          <div class="inline" style="margin-top:6px">
            <button id="btnGenPy" class="ghost">Generate Python Script</button>
            <button id="btnGenFish" class="ghost">Generate Fish Script</button>
          </div>
          <p class="small muted">Scripts reference the data file name you download from "Extract Pixel Data". Adjust paths in your solver as needed.</p>
          <h3 class="small muted" style="margin-top:18px">Grayscale Proportions</h3>
          <div id="propCheckboxes" class="checkboxes"></div>
          <button id="btnProps" class="ghost" disabled>Display Proportions</button>
        </div>
      </div>
    </section>

    <section class="grid">
      <div class="panel">
        <h3 class="small muted">Image</h3>
        <canvas id="imgCanvas" width="300" height="300"></canvas>
      </div>
      <div class="panel">
        <h3 class="small muted">Histogram (grayscale)</h3>
        <canvas id="histCanvas" width="300" height="300"></canvas>
      </div>
    </section>
  </main>

<script>
// ==== State ====
const state = {
  mode: '2D', // '2D' | '3D'
  files: [], // File[]
  images: [], // ImageBitmap[] (original, possibly resized)
  gray: [],   // Uint8ClampedArray per image
  equalized: [], // Uint8ClampedArray per image
  processed: [], // Uint8ClampedArray per image
  currentIndex: 0,
  lastDataFilename: null,
};

// ==== DOM ====
const modeSel = document.getElementById('mode');
const fileInput = document.getElementById('fileInput');
const btnLoad = document.getElementById('btnLoad');
const btnResize = document.getElementById('btnResize');
const resizeW = document.getElementById('resizeW');
const resizeH = document.getElementById('resizeH');
const btnGray = document.getElementById('btnGray');
const btnEq = document.getElementById('btnEq');
const thresholdsInp = document.getElementById('thresholds');
const btnThresh = document.getElementById('btnThresh');
const btnSaveImg = document.getElementById('btnSaveImg');
const sampleWidth = document.getElementById('sampleWidth');
const sampleHeight = document.getElementById('sampleHeight');
const scalingFactor = document.getElementById('scalingFactor');
const originSel = document.getElementById('origin');
const pixelCheckboxes = document.getElementById('pixelCheckboxes');
const btnExtract = document.getElementById('btnExtract');
const propCheckboxes = document.getElementById('propCheckboxes');
const btnProps = document.getElementById('btnProps');
const codeType = document.getElementById('codeType');
const btnGenPy = document.getElementById('btnGenPy');
const btnGenFish = document.getElementById('btnGenFish');
const imgCanvas = document.getElementById('imgCanvas');
const histCanvas = document.getElementById('histCanvas');
const ictx = imgCanvas.getContext('2d');
const hctx = histCanvas.getContext('2d');

modeSel.addEventListener('change', () => {
  state.mode = modeSel.value;
  sampleHeight.disabled = state.mode !== '3D';
  fileInput.multiple = (state.mode === '3D');
});

btnLoad.addEventListener('click', async () => {
  if (!fileInput.files || fileInput.files.length === 0) { alert('Pick image file(s).'); return; }
  state.files = Array.from(fileInput.files);
  if (state.mode === '2D' && state.files.length > 1) state.files = [state.files[0]];
  state.images = await loadImages(state.files);
  state.currentIndex = 0;
  state.gray = new Array(state.images.length).fill(null);
  state.equalized = new Array(state.images.length).fill(null);
  state.processed = new Array(state.images.length).fill(null);
  btnGray.disabled = false; btnResize.disabled = false; btnThresh.disabled = true; btnEq.disabled = true; btnSaveImg.disabled = false;
  drawImageToCanvas(state.images[0]);
});

btnResize.addEventListener('click', async () => {
  const w = parseInt(resizeW.value, 10), h = parseInt(resizeH.value, 10);
  if (!(w>0 && h>0)) { alert('Enter valid width and height'); return; }
  state.images = await Promise.all(state.images.map(img => resizeBitmap(img, w, h)));
  // Invalidate downstream arrays
  state.gray = new Array(state.images.length).fill(null);
  state.equalized = new Array(state.images.length).fill(null);
  state.processed = new Array(state.images.length).fill(null);
  drawImageToCanvas(state.images[state.currentIndex]);
});

btnGray.addEventListener('click', async () => {
  state.gray = state.images.map(img => toGrayscale(img));
  state.equalized.fill(null);
  state.processed.fill(null);
  renderCurrentGray();
  btnEq.disabled = false; btnThresh.disabled = false; btnSaveImg.disabled = false; btnExtract.disabled = false; btnProps.disabled = false;
});

btnEq.addEventListener('click', () => {
  if (!state.gray[0]) { alert('Convert to grayscale first.'); return; }
  state.equalized = state.gray.map(eqHist);
  state.processed = new Array(state.images.length).fill(null);
  renderCurrentGray(true);
});

btnThresh.addEventListener('click', () => {
  const th = parseCSVInts(thresholdsInp.value, 0, 255).sort((a,b)=>a-b).filter((v,i,a)=>a.indexOf(v)===i);
  if (!state.gray[0]) { alert('Convert to grayscale first.'); return; }
  const srcArrs = state.equalized[0] ? state.equalized : state.gray;
  state.processed = srcArrs.map(arr => applyThresholds(arr, th));
  renderCurrentProcessed();
  // build checkboxes from unique values in processed[0]
  const uniq = uniqueValues(state.processed[0]);
  buildCheckboxes(propCheckboxes, uniq);
  buildCheckboxes(pixelCheckboxes, uniq);
});

btnSaveImg.addEventListener('click', () => {
  const arr = state.processed[0] || state.equalized[0] || state.gray[0];
  if (!arr) {
    // Download current original bitmap
    downloadBitmap(state.images[state.currentIndex], 'image.png');
  } else {
    const bmp = arrayToBitmap(arr, state.images[state.currentIndex].width, state.images[state.currentIndex].height);
    downloadBitmap(bmp, 'image_processed.png');
  }
});

btnProps.addEventListener('click', () => {
  const arrs = getActiveImageArrays();
  if (!arrs) { alert('Process an image first.'); return; }
  const selected = selectedValues(propCheckboxes);
  if (selected.length===0){ alert('Select at least one grayscale value.'); return; }
  const counts = new Map(selected.map(v=>[v,0]));
  arrs.forEach(arr => {
    for (let i=0;i<arr.length;i++) {
      const v = arr[i]; if (counts.has(v)) counts.set(v, counts.get(v)+1);
    }
  });
  const total = Array.from(counts.values()).reduce((a,b)=>a+b,0);
  let txt='';
  counts.forEach((c,v)=>{ const p = total? (100*c/total) : 0; txt += `Grayscale ${v}: Count = ${c}, Proportion = ${p.toFixed(2)}%\n`; });
  alert(txt);
});

btnExtract.addEventListener('click', () => {
  const arrs = getActiveImageArrays();
  if (!arrs) { alert('Process an image first (grayscale/equalized/thresholded).'); return; }
  const Wm = parseFloat(sampleWidth.value); if (!(Wm>0)) { alert('Enter Sample Width (m)'); return; }
  const Sm = parseFloat(scalingFactor.value)||1.0;
  const width_px = getCurrentWidth();
  const pixel_width = (Wm / width_px) * Sm;
  let z_inc = 0;
  if (state.mode==='3D'){
    const Hm = parseFloat(sampleHeight.value); if (!(Hm>0)) { alert('Enter Sample Height (m) for 3D'); return; }
    z_inc = (Hm / arrs.length) * Sm;
  }
  const origin = originSel.value;
  const selected = selectedValues(pixelCheckboxes);
  if (selected.length===0){ alert('Select grayscale values for extraction.'); return; }

  const lines = ["pos-x(m), pos-y(m), pos-z(m), gray_value"]; 
  let z = 0;
  for (let imgIdx=0; imgIdx<arrs.length; imgIdx++){
    const arr = arrs[imgIdx];
    const w = getCurrentWidth(); const h = getCurrentHeight();
    const {cx, cy} = originCenter(origin, w, h, pixel_width);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const gray = arr[y*w + x];
        if (!selected.includes(gray)) continue;
        let px = (x * pixel_width) - cx;
        let py = (y * pixel_width) - cy; if (origin==='center') py = -py;
        const pz = (state.mode==='3D') ? z : 0;
        lines.push(`${px}, ${py}, ${pz}, ${gray}`);
      }
    }
    if (state.mode==='3D') z += z_inc;
  }
  if (state.mode==='3D'){
    // recenter z to make center 0
    const header = lines.shift();
    const rows = lines.map(s=>s.split(',').map(t=>t.trim()));
    const maxZ = Math.max(...rows.map(r=>parseFloat(r[2])));
    const half = maxZ/2;
    rows.forEach(r=>{ r[2] = (parseFloat(r[2]) - half).toString(); });
    const out = [header, ...rows.map(r=>r.join(', '))].join('\n');
    downloadText(out, 'pixel_data.txt');
  } else {
    downloadText(lines.join('\n'), 'pixel_data.txt');
  }
  state.lastDataFilename = 'pixel_data.txt';
});

btnGenPy.addEventListener('click', () => {
  const typ = codeType.value;
  const dataFile = state.lastDataFilename || 'pixel_data.txt';
  let content = '';
  if (typ==='Ball'){
    content = `import itasca as it\nfrom itasca import ballarray as ba\nimport numpy as np\n\nit.command("python-reset-state false")\nit.command("model new")\n\ndata = np.loadtxt("${dataFile}", delimiter=",", skiprows=1)\n\nfor idx, (pos_x, pos_y, pos_z, gray_value) in enumerate(data):\n    pos = [pos_x, pos_y, pos_z]\n    ball = ba.create(1, pos)\n    ball.set_extra(0, gray_value)\n\nit.command("model save 'BallsModel'")\n`;
  } else {
    content = `import itasca as it\nfrom itasca import rblock as rblock_module\nimport numpy as np\nfrom scipy.spatial import KDTree\nfrom collections import defaultdict\n\nit.command("python-reset-state false")\nit.command("model new")\nit.command("model large-strain on")\nit.command("model restore 'matGeom'")\nit.command("rblock group 'Quartz'")\n\ndata = np.loadtxt("${dataFile}", delimiter=",", skiprows=1)\npixel_w = 0.01 / (750 / 2)\n\n# Preprocess\ngrouped = defaultdict(list)\nfor datum in data:\n    pos, gravy = [datum[1], datum[0], datum[2]], datum[3]\n    grouped[gravy].append(pos)\n\nrpos = [rb.pos() for rb in rblock_module.list()]\nrids = [rb.id() for rb in rblock_module.list()]\nkd = KDTree(rpos)\nassigned = set()\n\ndef set_groups(name, positions, radius):\n    for pos in positions:\n        idxs = kd.query_ball_point(pos, radius)\n        for i in idxs:\n            if rids[i] in assigned: continue\n            rb = rblock_module.find(rids[i])\n            if rb is not None:\n                rb.set_group(name)\n                assigned.add(rids[i])\n\norder = [("Biotite", 250, 9.50*pixel_w/2), ("Plagioclase", 50, 4.82*pixel_w/2), ("K-feldspar", 150, 8.50*pixel_w/2)]\nfor name, gravy, rad in order:\n    set_groups(name, grouped[gravy], rad)\n\nit.command("model save 'Grouped'")\n`;
  }
  downloadText(content, typ==='Ball' ? 'script_ball.py' : 'script_rblock.py');
});

btnGenFish.addEventListener('click', () => {
  const dataFile = state.lastDataFilename || 'pixel_data.txt';
  const numPointsHint = '// In web version, count will be inferred at runtime by Python if needed.';
  const content = `model new\nmodel restore 'my_DEM_model'\n\n; Web-exported FISH snippet\n; Data file: ${dataFile}\n; ${numPointsHint}\n`; // Provide a minimal placeholder; full port is solver-specific
  downloadText(content, 'script.fish');
});

// ==== Image utilities ====
async function loadImages(files){
  const bitmaps = [];
  for (const f of files){
    const bmp = await createImageBitmap(f);
    bitmaps.push(bmp);
  }
  return bitmaps;
}

function drawImageToCanvas(bitmap){
  const scale = Math.min(300/bitmap.width, 300/bitmap.height);
  const w = Math.round(bitmap.width*scale), h = Math.round(bitmap.height*scale);
  imgCanvas.width = w; imgCanvas.height = h;
  ictx.clearRect(0,0,w,h);
  ictx.drawImage(bitmap, 0,0, w,h);
}

function resizeBitmap(bitmap, w, h){
  const off = new OffscreenCanvas(w,h); const c = off.getContext('2d');
  c.drawImage(bitmap, 0,0, w,h);
  return createImageBitmap(off);
}

function toGrayscale(bitmap){
  const off = new OffscreenCanvas(bitmap.width, bitmap.height); const c = off.getContext('2d');
  c.drawImage(bitmap,0,0);
  const img = c.getImageData(0,0,bitmap.width,bitmap.height);
  const d = img.data; const out = new Uint8ClampedArray(bitmap.width*bitmap.height);
  for (let i=0,j=0;i<d.length;i+=4, j++){
    const r=d[i], g=d[i+1], b=d[i+2];
    const y = Math.round(0.299*r + 0.587*g + 0.114*b);
    out[j] = y;
  }
  drawGrayToCanvas(out, bitmap.width, bitmap.height);
  drawHistogram(out);
  return out;
}

function eqHist(gray){
  // gray: Uint8ClampedArray
  const L = 256;
  const hist = new Uint32Array(L);
  for (let i=0;i<gray.length;i++) hist[gray[i]]++;
  const cdf = new Float64Array(L);
  cdf[0] = hist[0]; for (let i=1;i<L;i++) cdf[i]=cdf[i-1]+hist[i];
  const cdfMin = cdf.find(v=>v>0) || 0;
  const N = gray.length;
  const map = new Uint8ClampedArray(L);
  for (let i=0;i<L;i++) map[i] = Math.round((cdf[i]-cdfMin)/(N-cdfMin)*255);
  const out = new Uint8ClampedArray(gray.length);
  for (let i=0;i<gray.length;i++) out[i] = map[gray[i]];
  drawGrayToCanvas(out, getCurrentWidth(), getCurrentHeight());
  drawHistogram(out);
  return out;
}

function applyThresholds(gray, thresholds){
  const th = [...new Set(thresholds)].sort((a,b)=>a-b);
  const out = new Uint8ClampedArray(gray.length);
  for (let i=0;i<gray.length;i++){
    const v = gray[i];
    if (v===255) { out[i]=255; continue; }
    let value=255, lower=0;
    for (let t of th){ if (v>=lower && v<t){ value = t; break; } lower=t; value=255; }
    out[i]=value;
  }
  drawGrayToCanvas(out, getCurrentWidth(), getCurrentHeight());
  drawHistogram(out);
  return out;
}

function drawGrayToCanvas(arr, w, h){
  const scale = Math.min(300/w, 300/h);
  const dw = Math.round(w*scale), dh = Math.round(h*scale);
  imgCanvas.width = dw; imgCanvas.height = dh;
  const off = new OffscreenCanvas(w,h); const c = off.getContext('2d');
  const imgData = c.createImageData(w,h);
  const d = imgData.data;
  for (let i=0,j=0;i<d.length;i+=4, j++){
    const v = arr[j]; d[i]=v; d[i+1]=v; d[i+2]=v; d[i+3]=255;
  }
  c.putImageData(imgData,0,0);
  ictx.clearRect(0,0,dw,dh);
  ictx.drawImage(off, 0,0, dw,dh);
}

function drawHistogram(gray){
  const L=256; const hist = new Uint32Array(L);
  for (let i=0;i<gray.length;i++) hist[gray[i]]++;
  const max = Math.max(...hist);
  const W = histCanvas.width = 300, H = histCanvas.height = 300;
  hctx.clearRect(0,0,W,H);
  for (let x=0;x<L;x++){
    const v = hist[x]; const y = Math.round(v/max*H);
    hctx.fillStyle = '#888';
    hctx.fillRect(x*(W/L), H - y, Math.max(1, W/L), y);
  }
}

function arrayToBitmap(arr, w, h){
  const off = new OffscreenCanvas(w,h); const c = off.getContext('2d');
  const img = c.createImageData(w,h); const d = img.data;
  for (let i=0,j=0;i<d.length;i+=4, j++){ const v=arr[j]; d[i]=v; d[i+1]=v; d[i+2]=v; d[i+3]=255; }
  c.putImageData(img,0,0);
  return off.transferToImageBitmap();
}

function downloadBitmap(bmp, name){
  const off = new OffscreenCanvas(bmp.width, bmp.height); const c = off.getContext('2d');
  c.drawImage(bmp,0,0);
  off.convertToBlob({type:'image/png'}).then(blob=> saveBlob(blob, name));
}

function saveBlob(blob, name){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }
function downloadText(text, name){ saveBlob(new Blob([text],{type:'text/plain'}), name); }

function parseCSVInts(s, lo, hi){ if(!s.trim()) return []; return s.split(',').map(v=>parseInt(v.trim(),10)).filter(v=>!isNaN(v)&&v>=lo&&v<=hi); }
function uniqueValues(arr){ const set=new Set(arr); return Array.from(set).sort((a,b)=>a-b); }
function buildCheckboxes(container, values){ container.innerHTML=''; values.forEach((v,i)=>{ const id = `${container.id}_${v}`; const lab=document.createElement('label'); lab.className='small'; lab.innerHTML = `<input type="checkbox" id="${id}" checked> ${v}`; container.appendChild(lab); }); }
function selectedValues(container){ const out=[]; container.querySelectorAll('input[type=checkbox]').forEach(ch=>{ if(ch.checked){ const v=parseInt(ch.id.split('_').pop(),10); out.push(v); } }); return out; }

function getCurrentWidth(){ return state.images[state.currentIndex]?.width || 0; }
function getCurrentHeight(){ return state.images[state.currentIndex]?.height || 0; }
function originCenter(origin, w, h, pw){
  if (origin==='center') return {cx:(Math.floor(w/2))*pw, cy:(Math.floor(h/2))*pw};
  if (origin==='top-left') return {cx:0, cy:0};
  if (origin==='top-right') return {cx:w*pw, cy:0};
  if (origin==='bottom-left') return {cx:0, cy:h*pw};
  if (origin==='bottom-right') return {cx:w*pw, cy:h*pw};
  return {cx:0, cy:0};
}

function renderCurrentGray(useEq=false){
  const arr = useEq && state.equalized[0] ? state.equalized[state.currentIndex] : state.gray[state.currentIndex];
  drawGrayToCanvas(arr, getCurrentWidth(), getCurrentHeight());
  drawHistogram(arr);
}
function renderCurrentProcessed(){
  const arr = state.processed[state.currentIndex];
  drawGrayToCanvas(arr, getCurrentWidth(), getCurrentHeight());
  drawHistogram(arr);
}
function getActiveImageArrays(){
  // Prefer processed -> equalized -> gray
  if (state.processed[0]) return state.processed;
  if (state.equalized[0]) return state.equalized;
  if (state.gray[0]) return state.gray;
  return null;
}
</script>
</body>
</html>
